<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Perfect Film Grain (WebGL 2.0 / PCG)</title>
    <style>
        body { 
            margin: 0; background: #080808; color: #ccc; 
            font-family: "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
            display: flex; height: 100vh; overflow: hidden;
        }

        #canvas-wrapper {
            flex-grow: 1; display: flex; justify-content: center; align-items: center;
            background-color: #000;
            background-image: 
                linear-gradient(45deg, #0d0d0d 25%, transparent 25%), 
                linear-gradient(-45deg, #0d0d0d 25%, transparent 25%), 
                linear-gradient(45deg, transparent 75%, #0d0d0d 75%), 
                linear-gradient(-45deg, transparent 75%, #0d0d0d 75%);
            background-size: 20px 20px;
            padding: 20px;
        }

        canvas {
            box-shadow: 0 0 40px rgba(0,0,0,1.0);
            max-width: 100%; max-height: 100%; object-fit: contain;
        }

        #controls {
            width: 320px; background: #111; border-left: 1px solid #222;
            padding: 20px 25px; display: flex; flex-direction: column; gap: 18px;
            overflow-y: auto; z-index: 100;
        }

        h1 { margin: 0 0 5px 0; font-size: 1.1rem; color: #fff; letter-spacing: 0.5px; }
        .citation { font-size: 0.7rem; color: #555; margin-bottom: 5px; line-height: 1.3; }
        .group-header { font-size: 0.7rem; text-transform: uppercase; letter-spacing: 1.2px; font-weight: 700; color: #555; border-bottom: 1px solid #222; padding-bottom: 4px; margin-bottom: 12px; }
        .control-row { margin-bottom: 12px; }
        label { display: flex; justify-content: space-between; font-size: 0.8rem; color: #aaa; margin-bottom: 6px; }
        .val { font-family: monospace; color: #4fa3d1; font-size: 0.85rem; }
        .desc { font-size: 0.7rem; color: #444; margin-top: 4px; line-height: 1.2; }

        input[type="range"] { -webkit-appearance: none; width: 100%; background: transparent; cursor: pointer; }
        input[type="range"]::-webkit-slider-thumb { -webkit-appearance: none; height: 14px; width: 14px; border-radius: 50%; background: #4fa3d1; margin-top: -5px; box-shadow: 0 0 8px rgba(79, 163, 209, 0.4); transition: transform 0.1s; }
        input[type="range"]::-webkit-slider-thumb:hover { transform: scale(1.2); }
        input[type="range"]::-webkit-slider-runnable-track { width: 100%; height: 4px; background: #333; border-radius: 2px; }
        #uShadowCtrl::-webkit-slider-runnable-track, #uExposure::-webkit-slider-runnable-track { background: linear-gradient(90deg, #333 50%, #444 50%); }

        .btn { background: #222; color: #ccc; border: 1px solid #333; padding: 12px; text-align: center; cursor: pointer; border-radius: 4px; font-size: 0.85rem; transition: 0.2s; font-weight: 600; }
        .btn:hover { background: #333; border-color: #555; color: #fff; }
        .btn-primary { background: #164263; border-color: #164263; color: #fff; }
        .btn-primary:hover { background: #1e5a85; }
        input[type="file"] { display: none; }
        .upload-zone { border: 1px dashed #333; padding: 15px; text-align: center; border-radius: 4px; cursor: pointer; transition: 0.2s; color: #888; font-size: 0.85rem; }
        .upload-zone:hover { background: #1a1a1a; border-color: #555; color: #fff; }
        #loading { display: none; color: #4fa3d1; font-size: 0.8rem; text-align: center; margin-top: 5px; }
    </style>
</head>
<body>

<div id="canvas-wrapper">
    <canvas id="glcanvas"></canvas>
</div>

<div id="controls">
    <div>
        <h1>Perfect Boolean Grain</h1>
        <div class="citation">WebGL 2.0 + PCG Hash (No Artifacts)</div>
    </div>

    <div>
        <div class="group-header">Source</div>
        <label class="upload-zone" for="fileInput"><span>ðŸ“‚ Load Image</span></label>
        <input type="file" id="fileInput" accept="image/*">
    </div>

    <div>
        <div class="group-header">Micro-Physics</div>
        <div class="control-row">
            <label>Radius <span id="lbl-radius" class="val">1.20px</span></label>
            <input type="range" id="uMuRadius" min="0.10" max="3.00" step="0.01" value="1.20">
        </div>
        <div class="control-row">
            <label>Variance <span id="lbl-sigma" class="val">0.20</span></label>
            <input type="range" id="uSigmaRadius" min="0.00" max="1.00" step="0.01" value="0.20">
        </div>
        <div class="control-row">
            <label>Optical Blur <span id="lbl-blur" class="val">0.50</span></label>
            <input type="range" id="uBlur" min="0.00" max="1.50" step="0.01" value="0.50">
        </div>
    </div>

    <div>
        <div class="group-header">Exposure</div>
        <div class="control-row">
            <label>Exposure (EV) <span id="lbl-exposure" class="val">0.00</span></label>
            <input type="range" id="uExposure" min="-2.0" max="2.0" step="0.05" value="0.0">
        </div>
        <div class="control-row">
            <label>Shadow Tone <span id="lbl-shadow" class="val">0.000</span></label>
            <input type="range" id="uShadowCtrl" min="-0.15" max="0.15" step="0.005" value="0.0">
        </div>
        <div class="control-row">
            <label>Seed <span id="lbl-seed" class="val">1</span></label>
            <input type="range" id="uSeed" min="0" max="1000" step="1" value="1">
        </div>
    </div>

    <div>
        <div class="group-header">Export</div>
        <div class="control-row">
            <label>Scale <span id="lbl-scale" class="val">1x</span></label>
            <input type="range" id="uScale" min="1" max="4" step="1" value="1">
            <div style="font-size: 0.7rem; color: #555; text-align: right; margin-top:2px;" id="res-info">Output: 0 x 0</div>
        </div>
        <button id="saveBtn" class="btn btn-primary">High-Res Develop</button>
        <div id="loading">Developing Negative...</div>
    </div>
</div>

<script id="vs" type="x-shader/x-vertex">#version 300 es
    in vec2 position;
    out vec2 vUv;
    void main() {
        vUv = position * 0.5 + 0.5;
        vUv.y = 1.0 - vUv.y; 
        gl_Position = vec4(position, 0.0, 1.0);
    }
</script>

<script id="fs" type="x-shader/x-fragment">#version 300 es
    precision highp float;

    uniform sampler2D uImage;
    uniform vec2 uResolution;
    uniform float uMuRadius;    
    uniform float uSigmaRadius; 
    uniform float uBlur;        
    uniform float uSeed;
    uniform float uShadowCtrl;
    uniform float uExposure;

    in vec2 vUv;
    out vec4 fragColor;

    #define PI 3.14159265359

    // --- PCG HASH (INTEGER RANDOM) ---
    // This is superior to float hashing (sin/fract) because it
    // does not lose precision at high coordinates or small scales.
    
    // Hash a single uint
    uint pcg(uint v) {
        uint state = v * 747796405u + 2891336453u;
        uint word = ((state >> ((state >> 28u) + 4u)) ^ state) * 277803737u;
        return (word >> 22u) ^ word;
    }

    // Hash a 2D position (uvec2) to a float 0..1
    float hash21(uvec2 p) {
        uint s = pcg(p.x ^ pcg(p.y));
        return float(s) * (1.0 / 4294967296.0);
    }

    // Hash a 2D position (uvec2) to a vec2 0..1
    vec2 hash22(uvec2 p) {
        uint s1 = pcg(p.x ^ pcg(p.y));
        uint s2 = pcg(p.y ^ pcg(p.x));
        return vec2(
            float(s1) * (1.0 / 4294967296.0),
            float(s2) * (1.0 / 4294967296.0)
        );
    }

    // Box-Muller for log-normal radius
    float randNormal(uvec2 seed) {
        vec2 u = hash22(seed);
        // Avoid 0 (log(0) is -inf)
        u.x = max(u.x, 0.00001); 
        return sqrt(-2.0 * log(u.x)) * cos(2.0 * PI * u.y);
    }

    float getDensity(float brightness, float meanArea) {
        float b = clamp(brightness, 0.0, 0.9999);
        return -log(1.0 - b) / meanArea;
    }

    void main() {
        // --- 1. Grid & Physics Setup ---
        float effectiveSize = uMuRadius; 
        float blurPadding = max(uBlur * 2.0, 0.0);
        float cellSize = max(effectiveSize * 2.2, max(blurPadding, 0.1));
        
        vec2 gridUv = vUv * uResolution / cellSize;
        vec2 cellIdFloat = floor(gridUv);
        
        // CONVERT TO INTEGER ID FOR HASHING
        // Offset by seed to randomize
        uvec2 cellId = uvec2(ivec2(cellIdFloat)) + uvec2(uint(uSeed * 100.0));
        
        float expansion = exp(2.0 * uSigmaRadius * uSigmaRadius);
        float meanArea = PI * uMuRadius * uMuRadius * expansion;
        
        float minDist = 999.0;

        // --- 2. Grain Generation Loop ---
        for (int y = -1; y <= 1; y++) {
            for (int x = -1; x <= 1; x++) {
                vec2 neighborOff = vec2(float(x), float(y));
                
                // Float ID for position calc
                vec2 neighborIdFloat = cellIdFloat + neighborOff;
                
                // Int ID for Hashing
                uvec2 neighborId = cellId + uvec2(ivec2(x, y)); 

                // Sample Texture
                vec2 sampleUv = (neighborIdFloat + 0.5) * cellSize / uResolution;
                sampleUv = clamp(sampleUv, 0.0, 1.0);
                
                vec3 nCol = texture(uImage, sampleUv).rgb;
                float nBrit = dot(nCol, vec3(0.2126, 0.7152, 0.0722));
                
                // Exposure & Shadow
                float exposedBrit = nBrit * pow(2.0, uExposure);
                float nEffBrit;
                if (uShadowCtrl > 0.0) nEffBrit = exposedBrit + uShadowCtrl;
                else nEffBrit = max(0.0, exposedBrit + uShadowCtrl);
                
                // Density
                float lambda = getDensity(nEffBrit, meanArea);
                float expectedCount = lambda * (cellSize * cellSize);
                
                // Hash for count (High quality PCG)
                // We mix in a large constant to distinct from position hash
                float seedVal = hash21(neighborId + uvec2(1923u, 712u)); 
                
                int count = int(expectedCount);
                if (seedVal < fract(expectedCount)) count += 1;
                if (count > 32) count = 32;

                for (int i = 0; i < 32; i++) {
                    if (i >= count) break;
                    
                    // Unique ID per grain
                    uvec2 gSeed = neighborId + uvec2(uint(i) * 3141u, uint(i) * 2718u);
                    
                    // Position 0..1
                    vec2 localPos = hash22(gSeed);
                    vec2 grainPos = neighborIdFloat + localPos; 
                    
                    // Log-Normal Radius
                    float norm = randNormal(gSeed + uvec2(99u, 11u));
                    float r = uMuRadius * exp(uSigmaRadius * norm);
                    
                    vec2 diff = (grainPos - gridUv) * cellSize;
                    float dist = length(diff);
                    
                    minDist = min(minDist, dist - r);
                }
            }
        }

        float coverage = 1.0 - smoothstep(-uBlur, uBlur, minDist);
        fragColor = vec4(vec3(coverage), 1.0);
    }
</script>

<script>
    const canvas = document.getElementById('glcanvas');
    // switch to webgl2
    const gl = canvas.getContext('webgl2', { preserveDrawingBuffer: true });
    
    if (!gl) {
        alert("Your browser does not support WebGL 2.0. The PCG hash requires it.");
    }

    let originalImage = null;
    let imgTexture = gl.createTexture();
    let width = 800, height = 600;
    
    function compile(type, source) {
        const s = gl.createShader(type);
        gl.shaderSource(s, source);
        gl.compileShader(s);
        if(!gl.getShaderParameter(s, gl.COMPILE_STATUS)) {
            console.error(gl.getShaderInfoLog(s));
            return null;
        }
        return s;
    }
    
    const p = gl.createProgram();
    gl.attachShader(p, compile(gl.VERTEX_SHADER, document.getElementById('vs').text));
    gl.attachShader(p, compile(gl.FRAGMENT_SHADER, document.getElementById('fs').text));
    gl.linkProgram(p);
    gl.useProgram(p);
    
    gl.bindBuffer(gl.ARRAY_BUFFER, gl.createBuffer());
    gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([-1,-1, 3,-1, -1,3]), gl.STATIC_DRAW);
    const loc = gl.getAttribLocation(p, 'position');
    gl.enableVertexAttribArray(loc);
    gl.vertexAttribPointer(loc, 2, gl.FLOAT, false, 0, 0);
    
    const u = {
        img: gl.getUniformLocation(p, 'uImage'),
        res: gl.getUniformLocation(p, 'uResolution'),
        mu: gl.getUniformLocation(p, 'uMuRadius'),
        sig: gl.getUniformLocation(p, 'uSigmaRadius'),
        blur: gl.getUniformLocation(p, 'uBlur'),
        seed: gl.getUniformLocation(p, 'uSeed'),
        shdw: gl.getUniformLocation(p, 'uShadowCtrl'),
        exp: gl.getUniformLocation(p, 'uExposure')
    };

    function setTexture(img) {
        gl.bindTexture(gl.TEXTURE_2D, imgTexture);
        gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, img);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
    }
    
    gl.bindTexture(gl.TEXTURE_2D, imgTexture);
    gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, 1, 1, 0, gl.RGBA, gl.UNSIGNED_BYTE, new Uint8Array([30,30,30,255]));
    
    const ui = {
        file: document.getElementById('fileInput'),
        mu: document.getElementById('uMuRadius'),
        sig: document.getElementById('uSigmaRadius'),
        blur: document.getElementById('uBlur'),
        seed: document.getElementById('uSeed'),
        scale: document.getElementById('uScale'),
        shdw: document.getElementById('uShadowCtrl'),
        exp: document.getElementById('uExposure'),
        save: document.getElementById('saveBtn'),
        lbl: {
            mu: document.getElementById('lbl-radius'),
            sig: document.getElementById('lbl-sigma'),
            blur: document.getElementById('lbl-blur'),
            seed: document.getElementById('lbl-seed'),
            scale: document.getElementById('lbl-scale'),
            shdw: document.getElementById('lbl-shadow'),
            exp: document.getElementById('lbl-exposure')
        }
    };

    function updateSize(mult) {
        canvas.width = width * mult;
        canvas.height = height * mult;
        gl.viewport(0, 0, canvas.width, canvas.height);
        document.getElementById('res-info').innerText = `Output: ${canvas.width} x ${canvas.height}`;
    }

    function draw() {
        if(!gl) return;
        gl.uniform2f(u.res, canvas.width, canvas.height);
        gl.uniform1f(u.mu, parseFloat(ui.mu.value));
        gl.uniform1f(u.sig, parseFloat(ui.sig.value));
        gl.uniform1f(u.blur, parseFloat(ui.blur.value));
        gl.uniform1f(u.seed, parseFloat(ui.seed.value));
        gl.uniform1f(u.shdw, parseFloat(ui.shdw.value));
        gl.uniform1f(u.exp, parseFloat(ui.exp.value));
        gl.drawArrays(gl.TRIANGLES, 0, 3);
    }

    function bind(el, lbl, fmt) {
        el.addEventListener('input', () => {
            lbl.innerText = fmt ? fmt(el.value) : el.value;
            requestAnimationFrame(draw);
        });
    }
    
    bind(ui.mu, ui.lbl.mu, v => parseFloat(v).toFixed(2) + 'px');
    bind(ui.sig, ui.lbl.sig, v => parseFloat(v).toFixed(2));
    bind(ui.blur, ui.lbl.blur, v => parseFloat(v).toFixed(2));
    bind(ui.seed, ui.lbl.seed);
    bind(ui.shdw, ui.lbl.shdw, v => parseFloat(v).toFixed(3));
    bind(ui.exp, ui.lbl.exp, v => (v > 0 ? '+' : '') + parseFloat(v).toFixed(2));
    
    ui.scale.addEventListener('input', () => {
        ui.lbl.scale.innerText = ui.scale.value + 'x';
        document.getElementById('res-info').innerText = `Output: ${width * ui.scale.value} x ${height * ui.scale.value}`;
    });

    ui.file.addEventListener('change', e => {
        const f = e.target.files[0];
        if(!f) return;
        const r = new FileReader();
        r.onload = ev => {
            const img = new Image();
            img.onload = () => {
                originalImage = img;
                width = img.width;
                height = img.height;
                setTexture(img);
                updateSize(1);
                draw();
            };
            img.src = ev.target.result;
        };
        r.readAsDataURL(f);
    });

    ui.save.addEventListener('click', () => {
        if(!originalImage) return alert("Open an image first");
        const s = parseInt(ui.scale.value);
        document.getElementById('loading').style.display = 'block';
        setTimeout(() => {
            updateSize(s);
            draw();
            canvas.toBlob(blob => {
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = `perfect_grain_${width*s}x${height*s}.png`;
                a.click();
                URL.revokeObjectURL(url);
                updateSize(1);
                draw();
                document.getElementById('loading').style.display = 'none';
            });
        }, 50);
    });

    updateSize(1);
    draw();

</script>
</body>
</html>
